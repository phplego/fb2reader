<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>FB2 Reader + Translator (OpenRouter) v1.3</title>
        <link
            rel="icon"
            type="image/svg+xml"
            sizes="any"
            href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiI+PHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iOCIgY3k9IjgiIHI9IjYiIGZpbGw9IiMwMGZmNDEiLz48L3N2Zz4="
        />
        <style>
            :root {
                --bg: #0b0f14;
                --panel: #121821;
                --muted: #6b7a90;
                --text: #e9eef7;
                --accent: #7bd88f;
                --accent-2: #5da9ff;
                --danger: #ff6b6b;
                --border: #1e2633;
                --chip: #0f141d;
                --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            }
            html,
            body {
                height: 100%;
            }
            body {
                margin: 0;
                background: linear-gradient(180deg, var(--bg), #0e141d);
                color: var(--text);
                font:
                    15px/1.6 system-ui,
                    -apple-system,
                    Segoe UI,
                    Roboto,
                    Ubuntu,
                    Cantarell,
                    "Helvetica Neue",
                    Arial,
                    "Apple Color Emoji",
                    "Segoe UI Emoji";
            }
            header {
                position: sticky;
                top: 0;
                z-index: 3;
                backdrop-filter: saturate(1.2) blur(6px);
                background: rgba(10, 14, 20, 0.7);
                border-bottom: 1px solid var(--border);
            }
            .bar {
                display: flex;
                gap: 0.75rem;
                align-items: center;
                padding: 0.7rem 1rem;
                flex-wrap: wrap;
            }
            .title {
                font-weight: 700;
                letter-spacing: 0.2px;
                margin-right: 0.5rem;
            }
            .spacer {
                flex: 1;
            }
            .chip {
                background: var(--chip);
                border: 1px solid var(--border);
                color: var(--text);
                padding: 0.45rem 0.65rem;
                border-radius: 10px;
                display: inline-flex;
                align-items: center;
                gap: 0.5rem;
            }
            input[type="file"],
            select,
            input[type="text"] {
                color: var(--text);
                background: var(--panel);
                border: 1px solid var(--border);
                border-radius: 10px;
                padding: 0.5rem 0.6rem;
                outline: none;
                box-shadow: none;
            }
            input[type="text"]::placeholder {
                color: #8b97aa;
            }
            button {
                background: linear-gradient(180deg, #182235, #111827);
                color: var(--text);
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 0.55rem 0.8rem;
                cursor: pointer;
                box-shadow: var(--shadow);
                transition: transform 0.03s ease;
            }
            button:hover {
                transform: translateY(-1px);
            }
            button.accent {
                background: linear-gradient(180deg, #0f2b1b, #0b2015);
                border-color: #163b27;
                color: #c6f7d0;
            }
            button.blue {
                background: linear-gradient(180deg, #0e2240, #0a1a31);
                border-color: #143058;
                color: #cae1ff;
            }
            button.danger {
                background: linear-gradient(180deg, #3a1212, #2a0e0e);
                border-color: #6b1f1f;
                color: #ffdada;
            }
            main {
                max-width: 980px;
                margin: 1rem auto 4rem;
                padding: 0 1rem;
            }
            .file-meta {
                color: var(--muted);
                margin: 0.35rem 0 1rem;
                display: flex;
                gap: 1rem;
                flex-wrap: wrap;
            }
            .para {
                background: rgba(255, 255, 255, 0.02);
                border: 1px solid var(--border);
                border-radius: 16px;
                padding: 1rem 0.9rem;
                margin: 0.6rem 0;
                box-shadow: var(--shadow);
                position: relative;
            }
            .para[data-status="loading"] {
                opacity: 0.7;
            }
            .para-number {
                position: absolute;
                left: -0.6rem;
                top: -0.6rem;
                background: #101724;
                border: 1px solid var(--border);
                padding: 0.25rem 0.5rem;
                border-radius: 11px;
                font-size: 0.8rem;
                color: #a8b7cc;
            }
            .para .original {
                cursor: pointer;
            }
            .para .original:hover {
                background: rgba(123, 216, 143, 0.08);
                transition: background 0.2s;
            }
            .actions {
                display: flex;
                gap: 0.5rem;
                align-items: center;
                margin-top: 0.6rem;
                flex-wrap: wrap;
                color: #9ab0c6;
                font-size: 0.9rem;
            }
            .actions .hint {
                opacity: 0.8;
            }
            .translation {
                margin-top: 0.75rem;
                padding: 0.75rem 0.75rem;
                border-left: 3px solid var(--accent);
                background: rgba(123, 216, 143, 0.08);
                border-radius: 10px;
            }
            .translation em {
                color: #d7ffe4;
            }
            .muted {
                color: var(--muted);
            }
            .badge {
                background: #0f1520;
                border: 1px solid var(--border);
                padding: 0.15rem 0.45rem;
                border-radius: 8px;
                font-size: 0.78rem;
            }
            .hidden {
                display: none !important;
            }
            .spinner {
                width: 14px;
                height: 14px;
                border: 2px solid #2a3648;
                border-top-color: var(--accent);
                border-radius: 50%;
                display: inline-block;
                animation: spin 0.8s linear infinite;
                vertical-align: -2px;
            }
            @keyframes spin {
                to {
                    transform: rotate(360deg);
                }
            }
            .divider {
                height: 1px;
                background: var(--border);
                margin: 1rem 0;
                opacity: 0.8;
            }
            .jump {
                display: flex;
                gap: 0.5rem;
                align-items: center;
                flex-wrap: wrap;
            }
            .footer-info {
                color: #8294ab;
                font-size: 0.88rem;
                margin-top: 1.2rem;
            }
            /* Modal */
            .modal {
                position: fixed;
                inset: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(0, 0, 0, 0.55);
                z-index: 10;
                padding: 1rem;
            }
            .modal > .card {
                width: min(620px, 100%);
                background: #0f1520;
                border: 1px solid var(--border);
                border-radius: 16px;
                box-shadow: var(--shadow);
                padding: 1rem;
                display: flex;
                flex-direction: column;
                gap: 0.6rem;
            }
            .card h3 {
                margin: 0.2rem 0 0.2rem;
                font-size: 1.15rem;
            }
            .card p {
                margin: 0.2rem 0;
                color: #9db0c7;
            }
            .row {
                display: flex;
                gap: 0.5rem;
                flex-wrap: wrap;
                align-items: center;
            }
            .grow {
                flex: 1;
            }
            code.k {
                background: #09111b;
                border: 1px solid #102033;
                padding: 0.15rem 0.35rem;
                border-radius: 8px;
            }
            .linklike {
                text-decoration: underline;
                cursor: pointer;
                color: #8ac8ff;
            }
        </style>
    </head>
    <body>
        <header>
            <div class="bar">
                <div class="title">üìñ FB2 ‚Üí Translator</div>

                <label class="chip">
                    <input id="fileInput" type="file" accept=".fb2,.xml" />
                    <span>Upload FB2</span>
                </label>

                <label class="chip" title="Target language">
                    <span>Language:</span>
                    <select id="lang">
                        <option value="ru" selected>Russian (ru)</option>
                        <option value="en">English (en)</option>
                        <option value="uk">Ukrainian (uk)</option>
                        <option value="de">Deutsch (de)</option>
                        <option value="fr">Fran√ßais (fr)</option>
                        <option value="es">Espa√±ol (es)</option>
                        <option value="it">Italiano (it)</option>
                        <option value="pl">Polski (pl)</option>
                        <option value="tr">T√ºrk√ße (tr)</option>
                        <option value="zh">‰∏≠Êñá (zh)</option>
                        <option value="ja">Êó•Êú¨Ë™û (ja)</option>
                    </select>
                </label>

                <label class="chip" title="Model on OpenRouter">
                    <span>Model:</span>
                    <input
                        id="model"
                        type="text"
                        value="qwen/qwen3-235b-a22b-2507"
                        size="18"
                    />
                </label>

                <button id="setKeyBtn" class="blue">üîë OpenRouter Key</button>
                <button id="ttsSettingsBtn" class="blue">üé§ TTS Settings</button>

                <div class="jump">
                    <input
                        id="gotoInput"
                        type="text"
                        placeholder="#para"
                        size="6"
                    />
                    <button id="gotoBtn">Go</button>
                    <button id="gotoLastBtn">‚Üì Last</button>
                </div>
                <div class="spacer"></div>
            </div>
        </header>

        <main>
            <div id="fileMeta" class="file-meta hidden"></div>
            <div id="output"></div>
            <div id="emptyState" class="footer-info">
                Upload a .fb2 file ‚Äî all paragraphs will be numbered. Clicking a
                paragraph sends a request to OpenRouter for translation and shows
                the result below the original.
                The first translation will ask for an API key and store it in
                <code class="k">localStorage</code>. Translations are cached
                locally (per file/language/paragraph).
            </div>
        </main>

        <!-- Modal: OpenRouter key -->
        <div id="keyModal" class="modal hidden" role="dialog" aria-modal="true">
            <div class="card">
                <h3>üîë OpenRouter API Key</h3>
                <p>
                    Create a key at
                    <span
                        class="linklike"
                        onclick="window.open('https://openrouter.ai/keys','_blank')"
                        >openrouter.ai/keys</span
                    >
                    and paste it here. The key will be saved locally and used
                    for translations.
                </p>
                <div class="row">
                    <input
                        id="apiKeyInput"
                        type="text"
                        class="grow"
                        placeholder="sk-or-v1-..."
                    />
                    <button id="saveKeyBtn" class="accent">Save</button>
                    <button id="closeKeyBtn">Cancel</button>
                </div>
                <p class="muted">
                    Your key is stored only in your browser. You can remove it
                    anytime via the ‚ÄúOpenRouter Key‚Äù button.
                </p>
            </div>
        </div>

        <!-- Modal: TTS settings -->
        <div id="ttsModal" class="modal hidden" role="dialog" aria-modal="true">
            <div class="card">
                <h3>üé§ TTS Settings (OpenAI)</h3>
                <p>Configure OpenAI Text-to-Speech. Your settings are stored locally.</p>
                <div class="row">
                    <label class="chip" style="border:none;background:transparent;padding:0">API Key:</label>
                    <input id="ttsApiKeyInput" type="text" class="grow" placeholder="sk-..." />
                </div>
                <div class="row">
                    <label class="chip" style="border:none;background:transparent;padding:0">Model:</label>
                    <input id="ttsModelInput" type="text" value="gpt-4o-mini-tts" />
                    <label class="chip" style="border:none;background:transparent;padding:0">Voice:</label>
                    <input id="ttsVoiceInput" type="text" value="sage" />
                </div>
                <div class="row">
                    <button id="saveTtsBtn" class="accent">Save</button>
                    <button id="closeTtsBtn">Close</button>
                </div>
                <p class="muted">Tip: voices like sage, verse, or others may be available depending on the model.</p>
            </div>
        </div>

        <script>
            (() => {
                const DEBUG = true;
                const orig_console_log = console.log;
                console.log = function () {
                    if (DEBUG) {
                        orig_console_log(...arguments);
                    }
                }

                const els = {
                    file: document.getElementById("fileInput"),
                    lang: document.getElementById("lang"),
                    model: document.getElementById("model"),
                    out: document.getElementById("output"),
                    meta: document.getElementById("fileMeta"),
                    empty: document.getElementById("emptyState"),
                    setKeyBtn: document.getElementById("setKeyBtn"),
                    keyModal: document.getElementById("keyModal"),
                    apiKeyInput: document.getElementById("apiKeyInput"),
                    saveKeyBtn: document.getElementById("saveKeyBtn"),
                    closeKeyBtn: document.getElementById("closeKeyBtn"),
                    gotoInput: document.getElementById("gotoInput"),
                    gotoBtn: document.getElementById("gotoBtn"),
                    gotoLastBtn: document.getElementById("gotoLastBtn"),
                    // TTS
                    ttsBtn: document.getElementById("ttsSettingsBtn"),
                    ttsModal: document.getElementById("ttsModal"),
                    ttsApiKeyInput: document.getElementById("ttsApiKeyInput"),
                    ttsModelInput: document.getElementById("ttsModelInput"),
                    ttsVoiceInput: document.getElementById("ttsVoiceInput"),
                    saveTtsBtn: document.getElementById("saveTtsBtn"),
                    closeTtsBtn: document.getElementById("closeTtsBtn"),
                };

                let state = {
                    apiKey: null, // OpenRouter
                    fileHash: null,
                    fileName: null,
                    bookTitle: null,
                    bookAuthor: null,
                    totalParas: 0,
                    // TTS
                    ttsApiKey: null,
                    ttsModel: 'gpt-4o-mini-tts',
                    ttsVoice: 'sage',
                    _audio: null,
                    _audioURL: null,
                };


                // ==== Local Storage helpers ====
                const LS_KEY = "openrouter_api_key";
                const LS_MODEL = "fb2_model";
                const LS_TTS_KEY = "openai_api_key";
                const LS_TTS_MODEL = "tts_model";
                const LS_TTS_VOICE = "tts_voice";
                const getTransKey = (hash, lang, idx) =>
                    `t_${hash}_${lang}_${idx}`;
                const getLastPosKey = (hash) => `lastpos_${hash}`;

                function loadPersisted() {
                    const k = localStorage.getItem(LS_KEY);
                    if (k) state.apiKey = k;
                    const m = localStorage.getItem(LS_MODEL);
                    if (m) els.model.value = m;
                    // TTS
                    const tk = localStorage.getItem(LS_TTS_KEY);
                    if (tk) state.ttsApiKey = tk;
                    const tm = localStorage.getItem(LS_TTS_MODEL);
                    if (tm) state.ttsModel = tm;
                    const tv = localStorage.getItem(LS_TTS_VOICE);
                    if (tv) state.ttsVoice = tv;
                }

                function ensureApiKey(force = false) {
                    if (force || !state.apiKey) {
                        els.apiKeyInput.value = state.apiKey || "";
                        els.keyModal.classList.remove("hidden");
                        els.apiKeyInput.focus({ preventScroll: true });
                        return false;
                    }
                    return true;
                }

                function saveApiKey() {
                    const v = (els.apiKeyInput.value || "").trim();
                    if (!v) return;
                    state.apiKey = v;
                    localStorage.setItem(LS_KEY, v);
                    els.keyModal.classList.add("hidden");
                }

                function removeApiKey() {
                    state.apiKey = null;
                    localStorage.removeItem(LS_KEY);
                }

                // TTS config helpers
                function openTtsModal() {
                    els.ttsApiKeyInput.value = state.ttsApiKey || '';
                    els.ttsModelInput.value = state.ttsModel || 'gpt-4o-mini-tts';
                    els.ttsVoiceInput.value = state.ttsVoice || 'sage';
                    els.ttsModal.classList.remove('hidden');
                    els.ttsApiKeyInput.focus({preventScroll:true});
                }
                function closeTtsModal() {
                    els.ttsModal.classList.add('hidden');
                }
                function ensureTtsConfig(force=false){
                    if (force || !state.ttsApiKey){
                        openTtsModal();
                        return false;
                    }
                    return true;
                }
                function saveTtsSettings(){
                    const key = (els.ttsApiKeyInput.value||'').trim();
                    const model = (els.ttsModelInput.value||'gpt-4o-mini-tts').trim();
                    const voice = (els.ttsVoiceInput.value||'sage').trim();
                    if (key) {
                        state.ttsApiKey = key;
                        localStorage.setItem(LS_TTS_KEY, key);
                    }
                    state.ttsModel = model;
                    state.ttsVoice = voice;
                    localStorage.setItem(LS_TTS_MODEL, model);
                    localStorage.setItem(LS_TTS_VOICE, voice);
                    closeTtsModal();
                }

                function stopAudio(){
                    if (state._audio){
                        try { state._audio.pause(); } catch(_){}
                        state._audio = null;
                    }
                    if (state._audioURL){
                        URL.revokeObjectURL(state._audioURL);
                        state._audioURL = null;
                    }
                }

                async function speakText(text, wrap){
                    if (!text) return;
                    if (!ensureTtsConfig(false)) return;
                    const link = wrap.querySelector('a.speak-loud');
                    try {
                        stopAudio();
                        if (link) link.textContent = 'Speaking‚Ä¶';
                        wrap.dataset.status = 'loading';
                        const response = await fetch('https://api.openai.com/v1/audio/speech', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${state.ttsApiKey}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                model: state.ttsModel || 'gpt-4o-mini-tts',
                                voice: state.ttsVoice || 'sage',
                                input: text,
                                format: 'mp3'
                            })
                        });
                        if (!response.ok){
                            const t = await response.text();
                            throw new Error(`API error (${response.status}): ${t.slice(0,300)}`);
                        }
                        const buf = await response.arrayBuffer();
                        const blob = new Blob([buf], {type: 'audio/mpeg'});
                        const url = URL.createObjectURL(blob);
                        state._audioURL = url;
                        const audio = new Audio();
                        audio.src = url;
                        state._audio = audio;
                        audio.addEventListener('ended', ()=>{
                            if (link) link.textContent = 'Speak Loud';
                        });
                        audio.addEventListener('pause', ()=>{
                            if (link) link.textContent = 'Speak Loud';
                        });
                        if (link) link.textContent = 'Stop';
                        await audio.play();
                    } catch (err){
                        alert(err.message || String(err));
                        if (link) link.textContent = 'Speak Loud';
                    } finally {
                        delete wrap.dataset.status;
                    }
                }

                // ==== FB2 parsing ====
                async function computeHash(arrayBuffer) {
                    const hash = await crypto.subtle.digest(
                        "SHA-256",
                        arrayBuffer,
                    );
                    // to hex
                    const bytes = new Uint8Array(hash);
                    return [...bytes]
                        .map((b) => b.toString(16).padStart(2, "0"))
                        .join("");
                }

                function fb2ToParagraphNodes(xmlDoc) {
                    // Collect <p> inside <body> (any depth). Skip poems' <v>? We keep them as p for simplicity.
                    const bodies = Array.from(
                        xmlDoc.getElementsByTagName("body"),
                    );
                    const paras = [];
                    bodies.forEach((body, bi) => {
                        // Insert a body divider if multiple bodies
                        const pNodes = body.querySelectorAll("section p, p");
                        pNodes.forEach((p) => paras.push(p));
                    });
                    return paras;
                }

                function fb2ExtractTitle(doc) {
                    // Try <book-title> from description, or first title paragraph
                    const bt = doc.getElementsByTagName("book-title")[0];
                    if (bt && bt.textContent) return bt.textContent.trim();
                    const titleP = doc.querySelector("title p");
                    return titleP ? titleP.textContent.trim() : "Untitled";
                }

                function fb2ExtractAuthor(doc) {
                    const author = doc.getElementsByTagName("author")[0];
                    if (author && author.textContent) return author.textContent.trim();
                    return "Unknown";
                }

                function sanitizeInline(node) {
                    // Recursively convert allowed FB2 inline tags to HTML string
                    const ALLOWED = {
                        emphasis: "em",
                        strong: "strong",
                        sub: "sub",
                        sup: "sup",
                        strikethrough: "s",
                        code: "code",
                        a: "a",
                        i: "i",
                        b: "b",
                    };
                    if (node.nodeType === Node.TEXT_NODE) {
                        return node.nodeValue
                            .replace(/</g, "&lt;")
                            .replace(/>/g, "&gt;");
                    }
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const tag = node.tagName.toLowerCase();
                        if (tag in ALLOWED) {
                            const htmlTag = ALLOWED[tag];
                            let attrs = "";
                            if (htmlTag === "a") {
                                const href =
                                    node.getAttribute("href") ||
                                    node.getAttribute("l:href") ||
                                    "#";
                                attrs = ` href="${href.replace(/"/g, "&quot;")}" target="_blank" rel="noopener" `;
                            }
                            const inner = Array.from(node.childNodes)
                                .map(sanitizeInline)
                                .join("");
                            return `<${htmlTag}${attrs}>${inner}</${htmlTag}>`;
                        }
                        // Drop other tags but keep text
                        return Array.from(node.childNodes)
                            .map(sanitizeInline)
                            .join("");
                    }
                    return "";
                }

                function paragraphToHTML(pNode) {
                    // Titles sometimes appear as <p><strong>...</strong></p> ‚Äî we just render inline safely
                    return (
                        Array.from(pNode.childNodes)
                            .map(sanitizeInline)
                            .join("")
                            .trim() || pNode.textContent.trim()
                    );
                }

                // ==== Rendering ====
                function renderParagraphs(
                    paras
                ) {
                    state.totalParas = paras.length;
                    els.out.innerHTML = "";
                    els.meta.classList.remove("hidden");
                    els.empty.classList.add("hidden");
                    const lastPos = parseInt(
                        localStorage.getItem(getLastPosKey(state.fileHash)) || "0",
                        10,
                    );

                    els.meta.innerHTML = `
      <span class="badge">File: ${escapeHtml(state.fileName)}</span>
      <span class="badge">Title: ${escapeHtml(state.bookTitle)}</span>
      <span class="badge">Author: ${escapeHtml(state.bookAuthor)}</span>
      <span class="badge">Paragraphs: ${paras.length}</span>
      ${lastPos ? `<span class="badge">Last #${lastPos}</span>` : ""}
    `;

                    paras.forEach((pNode, i) => {
                        const idx = i + 1;
                        const html = paragraphToHTML(pNode);
                        if (!html) return;
                        const wrap = document.createElement("section");
                        wrap.className = "para";
                        wrap.id = `p-${idx}`;
                        wrap.dataset.idx = String(idx);

                        const num = document.createElement("div");
                        num.className = "para-number";
                        num.textContent = `#${idx}`;

                        const original = document.createElement("div");
                        original.className = "original";
                        original.innerHTML = html;

                        const actions = document.createElement("div");
                        actions.className = "actions";
                        actions.innerHTML = `
        <span class="hint">Click paragraph ‚Üí translate ‚Üì</span>
        <span class="muted">|</span>
        <span class="muted">Cached locally</span>
        <span class="muted">|</span>
        <a href="javascript:" class="force-translate muted">Translate</a>
        <span class="muted">|</span>
        <a href="javascript:" class="speak-loud muted">Speak Loud</a>
      `;

                        const translation = document.createElement("div");
                        translation.className = "translation hidden";
                        translation.innerHTML = `<span class="muted">Translation will appear here‚Ä¶</span>`;

                        wrap.appendChild(num);
                        wrap.appendChild(original);
                        wrap.appendChild(actions);
                        wrap.appendChild(translation);
                        els.out.appendChild(wrap);

                        // preload cached translation if exists
                        const cached = localStorage.getItem(
                            getTransKey(state.fileHash, els.lang.value, idx),
                        );
                        if (cached) {
                            translation.innerHTML = `${escapeHtml(cached)}`;
                            translation.classList.remove("hidden");
                        }

                        // Click to translate/toggle
                        wrap.addEventListener(
                            "click",
                            async (ev) => {
                                if (ev.target.closest("a.force-translate")) {
                                    await onTranslateClick(wrap, html, idx);
                                    return;
                                }
                                if (ev.target.closest('a.speak-loud')){
                                    // extract plain text from original HTML
                                    const tmpDiv = document.createElement('div');
                                    tmpDiv.innerHTML = html;
                                    const originalText = (tmpDiv.textContent||'').trim();
                                    if (!originalText) return;
                                    // If currently playing, stop
                                    if (state._audio && !state._audio.paused){
                                        stopAudio();
                                        ev.target.textContent = 'Speak Loud';
                                        return;
                                    }
                                    await speakText(originalText, wrap);
                                    return;
                                }
                                if (
                                    ev.target.closest(".original") &&
                                    translation.classList.contains("hidden") // click on the original works only once
                                ) {
                                    await onTranslateClick(wrap, html, idx);
                                }
                            },
                            false,
                        );
                    });

                    // Autoscroll to last
                    if (lastPos && document.getElementById(`p-${lastPos}`)) {
                        document.getElementById(`p-${lastPos}`).scrollIntoView({
                            behavior: "smooth",
                            block: "start",
                        });
                    }
                }

                // ==== Translation ====
                async function onTranslateClick(wrap, originalHtml, idx) {
                    const lang = els.lang.value;
                    const modelRaw = els.model.value.trim();
                    if (!ensureApiKey(false)) return;

                    const transEl = wrap.querySelector(".translation");
                    const cached = localStorage.getItem(
                        getTransKey(state.fileHash, lang, idx),
                    );
                    // Toggle if already present
                    if (cached) {
                        transEl.classList.toggle("hidden");
                        // Save last position
                        localStorage.setItem(
                            getLastPosKey(state.fileHash),
                            String(idx),
                        );
                    }

                    // strip HTML to plain text for LLM
                    const tmp = document.createElement("div");
                    tmp.innerHTML = originalHtml;
                    const originalText = tmp.textContent.trim();

                    if (!originalText) return;
                    wrap.dataset.status = "loading";
                    transEl.classList.remove("hidden");
                    transEl.innerHTML = `<span class="spinner"></span> <span class="muted">Translating via OpenRouter‚Ä¶</span>`;

                    try {
                        const model = (
                            modelRaw || "qwen/qwen3-235b-a22b-2507"
                        ).replace(/\/+$/, ""); // safely trim trailing '/'
                        localStorage.setItem(LS_MODEL, model);

                        const messages = [
                            {
                                role: "system",
                                content: `You are a precise translation engine. Translate the user's paragraph into ${lang}.
- It is the paragraph #${idx} from the book "${state.bookTitle}" written by "${state.bookAuthor}".
- Preserve meaning, tone and simple inline emphasis when obvious.
- Do NOT add commentary. Return ONLY the translation text.`,
                            },
                            { role: "user", content: originalText },
                        ];
                        console.log(messages[0].content);

                        const response = await fetch(
                            "https://openrouter.ai/api/v1/chat/completions",
                            {
                                method: "POST",
                                headers: {
                                    Authorization: `Bearer ${state.apiKey}`,
                                    "Content-Type": "application/json",
                                    "X-Title": "FB2 Paragraph Translator",
                                },
                                body: JSON.stringify({
                                    model,
                                    messages: messages,
                                    temperature: 0.7,
                                }),
                            },
                        );

                        if (!response.ok) {
                            const text = await response.text();
                            throw new Error(
                                `API error (${response.status}): ${text.slice(0, 300)}`,
                            );
                        }
                        const data = await response.json();
                        const output =
                            data.choices?.[0]?.message?.content?.trim();
                        if (!output) throw new Error("Empty model response");

                        // Cache and render
                        localStorage.setItem(
                            getTransKey(state.fileHash, lang, idx),
                            output,
                        );
                        transEl.innerHTML = `${escapeHtml(output)}`;
                        localStorage.setItem(
                            getLastPosKey(state.fileHash),
                            String(idx),
                        );
                    } catch (err) {
                        transEl.innerHTML = `<span style="color:var(--danger)">‚ùó ${escapeHtml(err.message || String(err))}</span>`;
                    } finally {
                        delete wrap.dataset.status;
                    }
                }

                // ==== UI actions ====
                els.setKeyBtn.addEventListener("click", () => {
                    if (state.apiKey) {
                        // offer to update or remove
                        const wantRemove = confirm(
                            "A key is already saved. Remove it?",
                        );
                        if (wantRemove) {
                            removeApiKey();
                            alert(
                                "Key removed. Click again to enter a new one.",
                            );
                        } else {
                            ensureApiKey(true);
                        }
                    } else {
                        ensureApiKey(true);
                    }
                });

                els.saveKeyBtn.addEventListener("click", () => {
                    saveApiKey();
                });
                els.closeKeyBtn.addEventListener("click", () => {
                    els.keyModal.classList.add("hidden");
                });

                // TTS buttons
                els.ttsBtn.addEventListener('click', ()=>{
                    openTtsModal();
                });
                els.saveTtsBtn.addEventListener('click', ()=>{
                    saveTtsSettings();
                });
                els.closeTtsBtn.addEventListener('click', ()=>{
                    closeTtsModal();
                });

                // file load
                els.file.addEventListener("change", async (e) => {
                    const file = e.target.files?.[0];
                    if (!file) return;
                    state.fileName = file.name;
                    const buf = await file.arrayBuffer();
                    state.fileHash = await computeHash(buf);

                    // parse XML
                    const text = new TextDecoder("utf-8").decode(buf);
                    let xml;
                    try {
                        xml = new DOMParser().parseFromString(text, "text/xml");
                        // if parsererror
                        if (xml.querySelector("parsererror")) {
                            throw new Error(
                                "Unable to parse XML. Make sure it is FB2.",
                            );
                        }
                    } catch (err) {
                        alert(
                            "FB2 parsing error: " +
                                (err.message || String(err)),
                        );
                        return;
                    }

                    // extract book title
                    state.bookTitle = fb2ExtractTitle(xml);
                    state.bookAuthor = fb2ExtractAuthor(xml);

                    const paras = fb2ToParagraphNodes(xml);
                    if (!paras.length) {
                        alert("No <p> paragraphs found in the file.");
                        return;
                    }
                    renderParagraphs(paras);
                });

                // goto paragraph
                els.gotoBtn.addEventListener("click", () => gotoPara());
                els.gotoInput.addEventListener("keydown", (ev) => {
                    if (ev.key === "Enter") gotoPara();
                });

                function gotoPara(num = null) {
                    let v = 0;
                    if (num != null) {
                        v = num;
                    } else {
                        v = parseInt(els.gotoInput.value.trim(), 10);
                    }
                    if (!v || v < 1 || v > state.totalParas) return;
                    const el = document.getElementById(`p-${v}`);
                    if (el) {
                        el.scrollIntoView({
                            behavior: "smooth",
                            block: "start",
                        });
                        el.classList.add("focus");
                        setTimeout(() => el.classList.remove("focus"), 900);
                    }
                }

                // goto last position button
                els.gotoLastBtn.addEventListener("click", () => {
                    const lastPos = parseInt(
                        localStorage.getItem(getLastPosKey(state.fileHash)) ||
                            "0",
                        10,
                    );
                    gotoPara(lastPos);
                });

                // helpers
                function escapeHtml(s) {
                    return String(s).replace(
                        /[&<>"']/g,
                        (m) =>
                            ({
                                "&": "&amp;",
                                "<": "&lt;",
                                ">": "&gt;",
                                '"': "&quot;",
                                "'": "&#39;",
                            })[m],
                    );
                }

                // init
                loadPersisted();
                // Prompt for OpenRouter key lazily on first translation; but we can hint early
                setTimeout(() => {
                    if (!state.apiKey) ensureApiKey(false);
                }, 500);
            })();
        </script>

        <script>
            /* ===== Parallel Dialog (drop-in) v0.1 ‚Äî self-contained ===== */
            (function ParallelDialogInstaller(){
                const CSS = `
  .pd-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:9999;padding:16px}
  .pd-backdrop.pd-open{display:flex}
  .pd-card{width:min(1100px,96vw);max-height:90vh;overflow:auto;background:#0f1520;border:1px solid #222733;border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.35)}
  .pd-top{display:flex;align-items:center;gap:8px;position:sticky;top:0;background:#0f1220;border-bottom:1px solid #222733;padding:10px 12px}
  .pd-title{color:#9aa3b2;text-transform:uppercase;font-size:12px;letter-spacing:.08em}
  .pd-x{margin-left:auto;border:0;background:#0f1220;color:#e6eaf0;font-size:22px;line-height:1;padding:6px 10px;cursor:pointer;border-radius:10px}
  .pd-grid{display:grid;grid-template-columns:1fr 1fr}
  .pd-head{display:grid;grid-template-columns:1fr 1fr;background:#0f1220;border-bottom:1px solid #222733}
  .pd-head div{padding:10px 14px;color:#9aa3b2;text-transform:uppercase;font-size:12px;letter-spacing:.08em}
  .pd-row{display:grid;grid-template-columns:1fr 1fr;border-bottom:1px solid #222733;background:#101420}
  .pd-row:nth-child(even){background:#0f1320}
  .pd-cell{padding:12px 14px;overflow-wrap:anywhere}
  .pd-idx{color:#9aa3b2;font-size:12px;margin-right:.5ch}
  .pd-row{scroll-margin:84px}
  @media (max-width:820px){.pd-head{grid-template-columns:1fr}.pd-row{grid-template-columns:1fr}}
  .pd-mini-btn{margin-left:8px;background:linear-gradient(180deg,#0e2240,#0a1a31);color:#cae1ff;border:1px solid #143058;border-radius:9px;padding:2px 8px;font-size:12px;cursor:pointer}
  `;

                // inject styles once
                const styleTag = document.createElement('style');
                styleTag.textContent = CSS;
                document.head.appendChild(styleTag);

                // create modal DOM once
                const backdrop = document.createElement('div');
                backdrop.className = 'pd-backdrop';
                backdrop.innerHTML = `
    <div class="pd-card" role="dialog" aria-modal="true" aria-labelledby="pd-title">
      <div class="pd-top">
        <div id="pd-title" class="pd-title">Original ‚Üî Translation</div>
        <button class="pd-x" aria-label="Close">√ó</button>
      </div>
      <div class="pd-body"></div>
    </div>`;
                document.body.appendChild(backdrop);
                const body = backdrop.querySelector('.pd-body');
                const closeBtn = backdrop.querySelector('.pd-x');

                function openModal(html, scrollToIdx){
                    body.innerHTML = html;
                    backdrop.classList.add('pd-open');
                    //document.body.style.overflow = 'hidden';
                    closeBtn.focus();
                    if (scrollToIdx) {
                        const target = body.querySelector(`.pd-row[data-idx="${scrollToIdx}"]`);
                        if (target) target.scrollIntoView({block:'start'});
                    }
                }
                function closeModal(){
                    backdrop.classList.remove('pd-open');
                    document.body.style.overflow = '';
                }
                closeBtn.addEventListener('click', closeModal);
                backdrop.addEventListener('click', (e)=>{ if(e.target===backdrop) closeModal(); });
                document.addEventListener('keydown', (e)=>{ if(backdrop.classList.contains('pd-open') && e.key==='Escape') closeModal(); });

                // helpers
                const esc = s => String(s||'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]));
                const split = txt => (txt||'').replace(/\s+/g,' ').trim().match(/[^.!?‚Ä¶]+[.!?‚Ä¶]*|\S+/g)||[];

                // build side-by-side HTML
                function buildDialogHTML(originalText, translatedHTML){
                    // strip any inline tags from translation for clean splitting
                    const tmp = document.createElement('div'); tmp.innerHTML = translatedHTML;
                    const transText = tmp.textContent || '';
                    const A = split(originalText).map(s=>s.trim()).filter(Boolean);
                    const B = split(transText).map(s=>s.trim()).filter(Boolean);
                    const n = Math.max(A.length,B.length);
                    let rows = '';
                    for(let i=0;i<n;i++){
                        rows += `
        <section class="pd-row" data-idx="${i+1}">
          <div class="pd-cell"><span class="pd-idx">${i+1}.</span><span lang="en">${esc(A[i]||'')}</span></div>
          <div class="pd-cell"><span class="pd-idx">${i+1}.</span><span lang="en">${esc(B[i]||'')}</span></div>
        </section>`;
                    }
                    return `
      <div class="pd-head"><div>Original</div><div>Translation</div></div>
      ${rows}`;
                }

                // inject a tiny "xxx" button into each .translation that appears
                function ensureMiniButton(transEl){
                    if (!transEl || transEl.querySelector('.pd-mini-btn')) return;
                    const btn = document.createElement('button');
                    btn.className = 'pd-mini-btn';
                    btn.type = 'button';
                    btn.textContent = 'compare';
                    // place button at the end of translation block
                    transEl.append(btn);

                    btn.addEventListener('click', (e)=>{
                        e.stopPropagation();
                        const wrap = transEl.closest('.para');
                        if(!wrap) return;
                        // original HTML -> text
                        const origDiv = wrap.querySelector('.original');
                        const tmp = document.createElement('div'); tmp.innerHTML = origDiv ? origDiv.innerHTML : '';
                        const originalText = (tmp.textContent || '').trim();
                        const translatedHTML = transEl.innerHTML.replace(/<button[^>]*class="pd-mini-btn"[^>]*>.*?<\/button>/,''); // drop our button
                        const html = buildDialogHTML(originalText, translatedHTML);
                        openModal(html);
                    });
                }

                // Observe #output for any .translation becoming visible/filled
                const host = document.getElementById('output');
                if (host){
                    const scan = () => host.querySelectorAll('.translation').forEach(ensureMiniButton);
                    // run once now and after mutations
                    scan();
                    const mo = new MutationObserver(()=> scan());
                    mo.observe(host, {childList:true, subtree:true});
                }
            })();
        </script>
    </body>
</html>
